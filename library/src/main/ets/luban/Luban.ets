/**
 * Luban å›¾ç‰‡å‹ç¼©ä¸»ç±»
 * æä¾›é“¾å¼è°ƒç”¨ APIï¼Œä»¿ç…§ Android ç‰ˆæœ¬çš„ä½¿ç”¨æ–¹å¼
 */

import { fileIo } from '@kit.CoreFileKit';
import { LubanEngine } from './LubanEngine';
import { LubanUtils } from './LubanUtils';
import {
  CompressionPredicate,
  CompressConfig,
  CompressResult,
  CompressOptions,
  RenameCallback
} from './LubanTypes';

/**
 * Luban å‹ç¼©å™¨æ„å»ºç±»
 */
export class LubanBuilder {
  private config: CompressConfig;

  constructor(paths: string | string[]) {
    this.config = {
      paths: Array.isArray(paths) ? paths : [paths],
      ignoreBy: 100, // é»˜è®¤ 100KB
      focusAlpha: false, // é»˜è®¤ä¸ä¿ç•™é€æ˜é€šé“
      targetDir: '' // é»˜è®¤ä¸ºç©ºï¼Œä½¿ç”¨ç³»ç»Ÿç¼“å­˜ç›®å½•
    };
  }

  /**
   * è®¾ç½®å‹ç¼©æ¡ä»¶è¿‡æ»¤å™¨
   * @param predicate è¿‡æ»¤æ¡ä»¶
   * @returns æ„å»ºå™¨å®ä¾‹
   */
  filter(predicate: CompressionPredicate): LubanBuilder {
    this.config.filter = predicate;
    return this;
  }

  /**
   * è®¾ç½®å¿½ç•¥å‹ç¼©çš„æ–‡ä»¶å¤§å°é˜ˆå€¼
   * @param sizeInKB æ–‡ä»¶å¤§å°é˜ˆå€¼ï¼ˆKBï¼‰
   * @returns æ„å»ºå™¨å®ä¾‹
   */
  ignoreBy(sizeInKB: number): LubanBuilder {
    this.config.ignoreBy = sizeInKB;
    return this;
  }

  /**
   * è®¾ç½®æ˜¯å¦ä¿ç•™é€æ˜é€šé“
   * @param focusAlpha æ˜¯å¦ä¿ç•™é€æ˜é€šé“
   * @returns æ„å»ºå™¨å®ä¾‹
   */
  setFocusAlpha(focusAlpha: boolean): LubanBuilder {
    this.config.focusAlpha = focusAlpha;
    return this;
  }

  /**
   * è®¾ç½®ç›®æ ‡ç›®å½•
   * @param targetDir ç›®æ ‡ç›®å½•è·¯å¾„
   * @returns æ„å»ºå™¨å®ä¾‹
   */
  setTargetDir(targetDir: string): LubanBuilder {
    this.config.targetDir = targetDir;
    return this;
  }

  /**
   * è®¾ç½®å‹ç¼©å¼€å§‹å›è°ƒå‡½æ•°
   * @param callback å¼€å§‹å‹ç¼©æ—¶çš„å›è°ƒå‡½æ•°
   * @returns æ„å»ºå™¨å®ä¾‹
   */
  setOnStart(callback: () => void): LubanBuilder {
    this.config.onStart = callback;
    return this;
  }

  /**
   * è®¾ç½®å‹ç¼©æˆåŠŸå›è°ƒå‡½æ•°
   * @param callback å‹ç¼©æˆåŠŸæ—¶çš„å›è°ƒå‡½æ•°
   * @returns æ„å»ºå™¨å®ä¾‹
   */
  setOnSuccess(callback: (filePath: string) => void): LubanBuilder {
    this.config.onSuccess = callback;
    return this;
  }

  /**
   * è®¾ç½®å‹ç¼©é”™è¯¯å›è°ƒå‡½æ•°
   * @param callback å‹ç¼©å‡ºé”™æ—¶çš„å›è°ƒå‡½æ•°
   * @returns æ„å»ºå™¨å®ä¾‹
   */
  setOnError(callback: (error: Error) => void): LubanBuilder {
    this.config.onError = callback;
    return this;
  }

  /**
   * è®¾ç½®é‡å‘½åå›è°ƒå‡½æ•°
   * @param callback é‡å‘½åå›è°ƒå‡½æ•°
   * @returns æ„å»ºå™¨å®ä¾‹
   */
  setOnRename(callback: RenameCallback): LubanBuilder {
    this.config.onRename = callback;
    return this;
  }

  // ä¸ºæ–° API æä¾›æ›´ç®€æ´çš„åˆ«åæ–¹æ³•
  /**
   * è®¾ç½®å‹ç¼©å¼€å§‹å›è°ƒå‡½æ•°ï¼ˆåˆ«åï¼‰
   * @param callback å¼€å§‹å‹ç¼©æ—¶çš„å›è°ƒå‡½æ•°
   * @returns æ„å»ºå™¨å®ä¾‹
   */
  onStart(callback: () => void): LubanBuilder {
    return this.setOnStart(callback);
  }

  /**
   * è®¾ç½®å‹ç¼©æˆåŠŸå›è°ƒå‡½æ•°ï¼ˆåˆ«åï¼‰
   * @param callback å‹ç¼©æˆåŠŸæ—¶çš„å›è°ƒå‡½æ•°
   * @returns æ„å»ºå™¨å®ä¾‹
   */
  onSuccess(callback: (filePath: string) => void): LubanBuilder {
    return this.setOnSuccess(callback);
  }

  /**
   * è®¾ç½®å‹ç¼©é”™è¯¯å›è°ƒå‡½æ•°ï¼ˆåˆ«åï¼‰
   * @param callback å‹ç¼©å‡ºé”™æ—¶çš„å›è°ƒå‡½æ•°
   * @returns æ„å»ºå™¨å®ä¾‹
   */
  onError(callback: (error: Error) => void): LubanBuilder {
    return this.setOnError(callback);
  }

  /**
   * è®¾ç½®é‡å‘½åå›è°ƒå‡½æ•°ï¼ˆåˆ«åï¼‰
   * @param callback é‡å‘½åå›è°ƒå‡½æ•°
   * @returns æ„å»ºå™¨å®ä¾‹
   */
  onRename(callback: RenameCallback): LubanBuilder {
    return this.setOnRename(callback);
  }

  /**
   * å¯åŠ¨å¼‚æ­¥å‹ç¼©
   */
  async launch(): Promise<void> {
    if (this.config.onStart) {
      this.config.onStart();
    }

    try {
      // ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
      const targetDir = this.getTargetDirectory();
      await this.ensureDirectoryExists(targetDir);

      // è¿‡æ»¤éœ€è¦å‹ç¼©çš„æ–‡ä»¶
      const filteredPaths = this.filterPaths();

      if (filteredPaths.length === 0) {
        this.config.onError?.(new Error('æ²¡æœ‰éœ€è¦å‹ç¼©çš„æ–‡ä»¶'));
        return;
      }

      // å¹¶è¡Œå‹ç¼©å¤šä¸ªæ–‡ä»¶
      const compressTasks = filteredPaths.map(async (path) => {
        return await this.compressSingleFile(path, targetDir);
      });

      const results = await Promise.all(compressTasks);

      // å¤„ç†ç»“æœ
      for (const result of results) {
        if (result.success && result.filePath) {
          this.config.onSuccess?.(result.filePath);
        } else if (result.error) {
          this.config.onError?.(result.error);
        }
      }

    } catch (error) {
      this.config.onError?.(error as Error);
    }
  }

  /**
   * åŒæ­¥è·å–å‹ç¼©ç»“æœ
   * @returns å‹ç¼©åçš„æ–‡ä»¶åˆ—è¡¨
   */
  async get(): Promise<string[]> {
    const targetDir = this.getTargetDirectory();
    await this.ensureDirectoryExists(targetDir);

    const filteredPaths = this.filterPaths();
    const results: string[] = [];

    for (const path of filteredPaths) {
      const result = await this.compressSingleFile(path, targetDir);
      if (result.success && result.filePath) {
        results.push(result.filePath);
      } else if (result.error) {
        throw result.error;
      }
    }

    return results;
  }

  /**
   * å‹ç¼©å•ä¸ªæ–‡ä»¶
   * @param sourcePath æºæ–‡ä»¶è·¯å¾„
   * @param targetDir ç›®æ ‡ç›®å½•
   * @returns å‹ç¼©ç»“æœ
   */
  private async compressSingleFile(sourcePath: string, targetDir: string): Promise<CompressResult> {
    try {
      // é¢„å¤„ç†å›¾ç‰‡æ–‡ä»¶ï¼ˆå¤„ç† URI æƒé™é—®é¢˜ï¼‰
      const processedSourcePath = await LubanUtils.preprocessImageFile(sourcePath);
      console.log(`ğŸ”§ å‹ç¼©å•æ–‡ä»¶ - é¢„å¤„ç†: ${sourcePath} -> ${processedSourcePath}`);
      
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      if (!fileIo.accessSync(processedSourcePath)) {
        throw new Error(`æ–‡ä»¶ä¸å­˜åœ¨: ${processedSourcePath}`);
      }
      // æ£€æŸ¥æ–‡ä»¶å¤§å°æ˜¯å¦è¶…è¿‡é˜ˆå€¼
      const fileSize = fileIo.statSync(processedSourcePath).size;
      if (fileSize < (this.config.ignoreBy || 100) * 1024) {
        // æ–‡ä»¶å¤ªå°ï¼Œä¸éœ€è¦å‹ç¼©ï¼Œç›´æ¥å¤åˆ¶
        const fileName = this.generateFileName(sourcePath);
        const targetPath = `${targetDir}/${fileName}`;
        fileIo.copyFileSync(processedSourcePath, targetPath);

        const result: CompressResult = {
          success: true,
          filePath: targetPath,
          originalSize: fileSize,
          compressedSize: fileSize
        };
        return result;
      }

      // ç”Ÿæˆç›®æ ‡æ–‡ä»¶è·¯å¾„
      const fileName = this.generateFileName(sourcePath);
      const targetPath = `${targetDir}/${fileName}`;

      // è°ƒç”¨å‹ç¼©å¼•æ“ï¼ˆä¼ å…¥é¢„å¤„ç†åçš„è·¯å¾„ï¼‰
      return await LubanEngine.compressSingle(
        processedSourcePath,
        targetPath,
        this.config.focusAlpha || false
      );

    } catch (error) {
      const result: CompressResult = {
        success: false,
        error: error as Error
      };
      return result;
    }
  }

  /**
   * è¿‡æ»¤éœ€è¦å‹ç¼©çš„æ–‡ä»¶è·¯å¾„
   * @returns è¿‡æ»¤åçš„æ–‡ä»¶è·¯å¾„åˆ—è¡¨
   */
  private filterPaths(): string[] {
    if (!this.config.filter) {
      return this.config.paths;
    }

    return this.config.paths.filter(path => this.config.filter!.apply(path));
  }

  /**
   * ç”Ÿæˆæ–‡ä»¶å
   * @param sourcePath æºæ–‡ä»¶è·¯å¾„
   * @returns ç”Ÿæˆçš„æ–‡ä»¶å
   */
  private generateFileName(sourcePath: string): string {
    if (this.config.onRename) {
      return this.config.onRename(sourcePath);
    }

    const fileName = sourcePath.split('/').pop() || 'compressed';
    const nameWithoutExt = fileName.split('.')[0];
    const timestamp = Date.now();

    return `${nameWithoutExt}_luban_${timestamp}.jpg`;
  }

  /**
   * è·å–ç›®æ ‡ç›®å½•
   * @returns ç›®æ ‡ç›®å½•è·¯å¾„
   */
  private getTargetDirectory(): string {
    if (this.config.targetDir) {
      return this.config.targetDir;
    }

    // ä½¿ç”¨é»˜è®¤è¾“å‡ºç›®å½•ï¼ˆfilesDir/luban/ï¼‰
    return LubanUtils.getDefaultOutputDir();
  }

  /**
   * ç¡®ä¿ç›®å½•å­˜åœ¨
   * @param dirPath ç›®å½•è·¯å¾„
   */
  private async ensureDirectoryExists(dirPath: string): Promise<void> {
    try {
      if (!fileIo.accessSync(dirPath)) {
        fileIo.mkdirSync(dirPath, true);
      }
    } catch (error) {
      console.error('åˆ›å»ºç›®å½•å¤±è´¥:', error);
      throw new Error(`æ— æ³•åˆ›å»ºç›®æ ‡ç›®å½•: ${dirPath}`);
    }
  }
}

/**
 * Luban ä¸»ç±»
 */
export class Luban {
  /**
   * åˆ›å»º Luban æ„å»ºå™¨
   * @param paths å›¾ç‰‡è·¯å¾„ï¼Œå¯ä»¥æ˜¯å•ä¸ªè·¯å¾„æˆ–è·¯å¾„æ•°ç»„
   * @returns Luban æ„å»ºå™¨å®ä¾‹
   */
  static with(paths: string | string[]): LubanBuilder {
    return new LubanBuilder(paths);
  }

  /**
   * å¿«é€Ÿå‹ç¼©å•å¼ å›¾ç‰‡
   * @param sourcePath æºå›¾ç‰‡è·¯å¾„
   * @param targetPath ç›®æ ‡è·¯å¾„ï¼ˆå¯é€‰ï¼‰
   * @param options å‹ç¼©é€‰é¡¹ï¼ˆå¯é€‰ï¼‰
   * @returns å‹ç¼©ç»“æœ
   */
  static async compress(
    sourcePath: string,
    targetPath?: string,
    options?: CompressOptions
  ): Promise<CompressResult> {
    const targetDir = targetPath ?
    targetPath.substring(0, targetPath.lastIndexOf('/')) : getContext().cacheDir + '/luban';

    const fileName = targetPath ?
    targetPath.substring(targetPath.lastIndexOf('/') + 1) :
    LubanEngine.generateCompressedFileName(sourcePath, targetDir);

    const finalTargetPath = targetPath || `${targetDir}/${fileName}`;

    // ç¡®ä¿ç›®å½•å­˜åœ¨
    try {
      if (!fileIo.accessSync(targetDir)) {
        fileIo.mkdirSync(targetDir, true);
      }
    } catch (error) {
      const result: CompressResult = {
        success: false,
        error: new Error(`æ— æ³•åˆ›å»ºç›®æ ‡ç›®å½•: ${targetDir}`)
      };
      return result;
    }

    return await LubanEngine.compressSingle(
      sourcePath,
      finalTargetPath,
      options?.focusAlpha || false
    );
  }
} 