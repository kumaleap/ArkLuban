/**
 * Luban å‹ç¼©å¼•æ“æ ¸å¿ƒå®ç°
 * åŸºäºå¾®ä¿¡æœ‹å‹åœˆå‹ç¼©ç®—æ³•çš„é¸¿è’™ç‰ˆæœ¬
 */

import { image } from '@kit.ImageKit';
import { fileIo } from '@kit.CoreFileKit';
import { CompressFormat, CompressResult, ImageSize } from './LubanTypes';
import { LubanUtils } from './LubanUtils';

/**
 * å‹ç¼©å¼•æ“ç±»
 */
export class LubanEngine {
  private static readonly TAG = 'LubanEngine';

  /**
   * å‹ç¼©å•å¼ å›¾ç‰‡
   * @param sourcePath æºå›¾ç‰‡è·¯å¾„
   * @param targetPath ç›®æ ‡è·¯å¾„
   * @param focusAlpha æ˜¯å¦ä¿ç•™é€æ˜é€šé“
   * @returns å‹ç¼©ç»“æœ
   */
  static async compressSingle(
    sourcePath: string,
    targetPath: string,
    focusAlpha: boolean = false
  ): Promise<CompressResult> {
    try {
      // 0. è·å–åŸå§‹æ–‡ä»¶å¤§å°ï¼ˆæ”¯æŒ URI å’Œæ™®é€šè·¯å¾„ï¼‰
      const originalSize = await LubanUtils.getFileSizeInBytes(sourcePath);
      console.log(`ğŸ“ åŸå§‹æ–‡ä»¶å¤§å°: ${originalSize} å­—èŠ‚`);
      
      // 1. é¢„å¤„ç†å›¾ç‰‡æ–‡ä»¶ï¼ˆå¤„ç†æƒé™é™åˆ¶çš„ URIï¼‰
      const processedSourcePath = await LubanUtils.preprocessImageFile(sourcePath);
      console.log(`ğŸ”§ é¢„å¤„ç†å›¾ç‰‡: ${sourcePath} -> ${processedSourcePath}`);
      
      // 2. è¯»å–åŸå›¾ä¿¡æ¯ï¼ˆprocessedSourcePath å·²ç»æ˜¯å¯è®¿é—®çš„æ™®é€šè·¯å¾„ï¼‰
      const sourceFile = fileIo.openSync(processedSourcePath, fileIo.OpenMode.READ_ONLY);

      // 3. åˆ›å»ºå›¾ç‰‡æº
      const imageSource = image.createImageSource(sourceFile.fd);
      const imageInfo = await imageSource.getImageInfo();

      // 4. è®¡ç®—å‹ç¼©åçš„å°ºå¯¸
      const compressSize = LubanEngine.computeSize(imageInfo.size.width, imageInfo.size.height);

      // 5. åˆ¤æ–­æ˜¯å¦éœ€è¦å‹ç¼©
      if (!LubanEngine.needCompress(originalSize, compressSize.width, compressSize.height)) {
        // ä¸éœ€è¦å‹ç¼©ï¼Œç›´æ¥å¤åˆ¶æ–‡ä»¶
        fileIo.copyFileSync(processedSourcePath, targetPath);

        const result: CompressResult = {
          success: true,
          filePath: targetPath,
          originalSize: originalSize,
          compressedSize: originalSize
        };
        return result;
      }

      // 6. åˆ›å»ºè§£ç é€‰é¡¹
      const decodingOptions: image.DecodingOptions = {
        desiredSize: {
          width: compressSize.width,
          height: compressSize.height
        },
        desiredRegion: {
          x: 0,
          y: 0,
          size: {
            width: imageInfo.size.width,
            height: imageInfo.size.height
          }
        },
        desiredPixelFormat: image.PixelMapFormat.RGBA_8888
      };

      // 7. è§£ç å›¾ç‰‡
      const pixelMap = await imageSource.createPixelMap(decodingOptions);

      // 8. åˆ›å»ºå›¾ç‰‡æ‰“åŒ…å™¨
      const imagePackerApi = image.createImagePacker();

      // 9. è®¾ç½®æ‰“åŒ…é€‰é¡¹
      const format = LubanEngine.getCompressFormat(processedSourcePath, focusAlpha);
      const quality = LubanEngine.computeQuality(originalSize);

      const packOpts: image.PackingOption = {
        format: format,
        quality: quality
      };

      // 10. å‹ç¼©å¹¶æ‰“åŒ…
      const compressedData = await imagePackerApi.packing(pixelMap, packOpts);

      // 11. å†™å…¥ç›®æ ‡æ–‡ä»¶
      const targetFile = fileIo.openSync(targetPath, fileIo.OpenMode.CREATE | fileIo.OpenMode.WRITE_ONLY);
      const writeLen = fileIo.writeSync(targetFile.fd, compressedData);
      fileIo.closeSync(targetFile.fd);
      fileIo.closeSync(sourceFile.fd);

      // 12. é‡Šæ”¾èµ„æº
      pixelMap.release();
      imagePackerApi.release();

      const result: CompressResult = {
        success: true,
        filePath: targetPath,
        originalSize: originalSize,
        compressedSize: writeLen
      };
      return result;

    } catch (error) {
      console.error(LubanEngine.TAG, `å‹ç¼©å¤±è´¥: ${error.message}`);
      const result: CompressResult = {
        success: false,
        error: error as Error
      };
      return result;
    }
  }

  /**
   * è®¡ç®—å‹ç¼©åçš„å°ºå¯¸ï¼ˆä»¿å¾®ä¿¡ç®—æ³•ï¼‰
   * @param srcWidth åŸå›¾å®½åº¦
   * @param srcHeight åŸå›¾é«˜åº¦
   * @returns å‹ç¼©åçš„å°ºå¯¸
   */
  private static computeSize(srcWidth: number, srcHeight: number): ImageSize {
    let width = srcWidth;
    let height = srcHeight;

    // 1. åˆ¤æ–­å›¾ç‰‡æ¯”ä¾‹ï¼ŒæŒ‰ç…§å¾®ä¿¡çš„å‹ç¼©ç­–ç•¥
    const ratio = width / height;

    if (ratio <= 1 && ratio > 0.5625) {
      // 1:1 åˆ° 16:9 ä¹‹é—´
      if (width < 1664) {
        if (width < 1280 && width > 720) {
          width = 720;
          height = width / ratio;
        } else if (width <= 720) {
          // ä¿æŒåŸå°ºå¯¸
        } else {
          width = 1280;
          height = width / ratio;
        }
      } else {
        width = 1664;
        height = width / ratio;
      }
    } else if (ratio <= 0.5625 && ratio > 0.5) {
      // 9:16 åˆ° 1:2 ä¹‹é—´
      height = 1664;
      width = height * ratio;
    } else if (ratio <= 0.5) {
      // é•¿å›¾
      height = 1280;
      width = height * ratio;
    } else {
      // å®½å›¾
      if (width < 1280) {
        // ä¿æŒåŸå°ºå¯¸
      } else {
        width = 1280;
        height = width / ratio;
      }
    }

    const result: ImageSize = {
      width: Math.floor(width),
      height: Math.floor(height)
    };
    return result;
  }

  /**
   * åˆ¤æ–­æ˜¯å¦éœ€è¦å‹ç¼©
   * @param fileSize æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
   * @param width å®½åº¦
   * @param height é«˜åº¦
   * @returns æ˜¯å¦éœ€è¦å‹ç¼©
   */
  private static needCompress(fileSize: number, width: number, height: number): boolean {
    // å°äº 100KB çš„å›¾ç‰‡ä¸å‹ç¼©
    if (fileSize < 100 * 1024) {
      return false;
    }

    // åƒç´ å°äº 32ä¸‡çš„å›¾ç‰‡ä¸å‹ç¼©
    if (width * height < 320000) {
      return false;
    }

    return true;
  }

  /**
   * è®¡ç®—å‹ç¼©è´¨é‡
   * @param fileSize æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
   * @returns å‹ç¼©è´¨é‡ (0-100)
   */
  private static computeQuality(fileSize: number): number {
    const fileSizeKB = fileSize / 1024;

    if (fileSizeKB < 150) {
      return 85;
    } else if (fileSizeKB < 300) {
      return 80;
    } else if (fileSizeKB < 500) {
      return 75;
    } else if (fileSizeKB < 1000) {
      return 70;
    } else if (fileSizeKB < 2000) {
      return 65;
    } else {
      return 60;
    }
  }

  /**
   * è·å–å‹ç¼©æ ¼å¼
   * @param sourcePath æºæ–‡ä»¶è·¯å¾„
   * @param focusAlpha æ˜¯å¦ä¿ç•™é€æ˜é€šé“
   * @returns å‹ç¼©æ ¼å¼
   */
  private static getCompressFormat(sourcePath: string, focusAlpha: boolean): string {
    const extension = sourcePath.toLowerCase().split('.').pop() || '';

    if (focusAlpha && (extension === 'png' || extension === 'webp')) {
      return extension === 'webp' ? CompressFormat.WEBP : CompressFormat.PNG;
    }

    return CompressFormat.JPEG;
  }

  /**
   * ç”Ÿæˆå‹ç¼©åçš„æ–‡ä»¶å
   * @param originalPath åŸæ–‡ä»¶è·¯å¾„
   * @param targetDir ç›®æ ‡ç›®å½•
   * @param customName è‡ªå®šä¹‰åç§°
   * @returns ç›®æ ‡æ–‡ä»¶è·¯å¾„
   */
  static generateCompressedFileName(
    originalPath: string,
    targetDir: string,
    customName?: string
  ): string {
    if (customName) {
      return `${targetDir}/${customName}`;
    }

    const fileName = originalPath.split('/').pop() || 'compressed';
    const nameWithoutExt = fileName.split('.')[0];
    const timestamp = Date.now();

    return `${targetDir}/${nameWithoutExt}_luban_${timestamp}.jpg`;
  }
} 