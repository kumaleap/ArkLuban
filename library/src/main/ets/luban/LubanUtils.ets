/**
 * Luban å·¥å…·ç±»
 * æä¾›æ–‡ä»¶æ£€æŸ¥ã€æ ¼å¼åˆ¤æ–­ç­‰å®ç”¨åŠŸèƒ½
 */

import { fileIo } from '@kit.CoreFileKit';
import fs from '@ohos.file.fs';
import { FilterCollection, CompressionPredicate } from './LubanTypes';

/**
 * Luban å·¥å…·ç±»
 */
export class LubanUtils {
  /**
   * æ”¯æŒçš„å›¾ç‰‡æ ¼å¼
   */
  private static readonly SUPPORTED_FORMATS = [
    'jpg', 'jpeg', 'png', 'webp', 'bmp', 'gif'
  ];

  /**
   * @deprecated æ­¤æ–¹æ³•å·²åºŸå¼ƒï¼Œè¯·ä½¿ç”¨ preprocessImageFile æ–¹æ³•
   * æ£€æµ‹å¹¶è½¬æ¢ URI è·¯å¾„
   * å¤„ç†é¸¿è’™ç³»ç»Ÿä¸­çš„ file:// URI
   * @param uriOrPath URI æˆ–æ™®é€šè·¯å¾„
   * @returns è½¬æ¢åçš„æ–‡ä»¶è·¯å¾„
   */
  static resolveFilePath(uriOrPath: string): string {
    console.warn('âš ï¸ resolveFilePath æ–¹æ³•å·²åºŸå¼ƒï¼Œå»ºè®®ä½¿ç”¨ preprocessImageFile æ–¹æ³•');
    
    if (!uriOrPath) {
      throw new Error('è·¯å¾„æˆ–URIä¸èƒ½ä¸ºç©º');
    }

    // å¦‚æœä¸æ˜¯ URIï¼Œç›´æ¥è¿”å›åŸè·¯å¾„
    if (!LubanUtils.isUri(uriOrPath)) {
      return uriOrPath;
    }

    // å¯¹äº URIï¼ŒæŠ›å‡ºé”™è¯¯æç¤ºä½¿ç”¨æ­£ç¡®çš„æ–¹æ³•
    throw new Error('URI éœ€è¦ä½¿ç”¨ preprocessImageFile æ–¹æ³•è¿›è¡Œé¢„å¤„ç†ï¼Œä¸èƒ½ç›´æ¥è½¬æ¢è·¯å¾„');
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸º URI æ ¼å¼
   * @param path è·¯å¾„å­—ç¬¦ä¸²
   * @returns æ˜¯å¦ä¸º URI
   */
  static isUri(path: string): boolean {
    if (!path) {
      return false;
    }
    return path.startsWith('file://') || path.startsWith('content://') || path.startsWith('datashare://');
  }

  /**
   * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºæ”¯æŒçš„å›¾ç‰‡æ ¼å¼
   * @param filePath æ–‡ä»¶è·¯å¾„æˆ–URI
   * @returns æ˜¯å¦ä¸ºæ”¯æŒçš„å›¾ç‰‡æ ¼å¼
   */
  static isImage(filePath: string): boolean {
    if (!filePath) {
      return false;
    }

    const extension = LubanUtils.getFileExtension(filePath);
    return LubanUtils.SUPPORTED_FORMATS.includes(extension);
  }

  /**
   * è·å–æ–‡ä»¶æ‰©å±•å
   * @param filePath æ–‡ä»¶è·¯å¾„
   * @returns æ–‡ä»¶æ‰©å±•åï¼ˆå°å†™ï¼‰
   */
  static getFileExtension(filePath: string): string {
    const fileName = filePath.split('/').pop() || '';
    const dotIndex = fileName.lastIndexOf('.');

    if (dotIndex === -1 || dotIndex === fileName.length - 1) {
      return '';
    }

    return fileName.substring(dotIndex + 1).toLowerCase();
  }

  /**
   * è·å–æ–‡ä»¶åï¼ˆä¸åŒ…å«æ‰©å±•åï¼‰
   * @param filePath æ–‡ä»¶è·¯å¾„
   * @returns æ–‡ä»¶å
   */
  static getFileNameWithoutExtension(filePath: string): string {
    const fileName = filePath.split('/').pop() || '';
    const dotIndex = fileName.lastIndexOf('.');

    if (dotIndex === -1) {
      return fileName;
    }

    return fileName.substring(0, dotIndex);
  }

  /**
   * è·å–æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰- æ”¯æŒ URI å’Œæ™®é€šè·¯å¾„
   * @param filePath æ–‡ä»¶è·¯å¾„æˆ– URI
   * @returns æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
   */
  static async getFileSizeInBytes(filePath: string): Promise<number> {
    try {
      if (LubanUtils.isUri(filePath)) {
        // å¯¹äº URIï¼Œé€šè¿‡ fs.open è·å–æ–‡ä»¶ä¿¡æ¯
        console.log(`ğŸ“ è·å– URI æ–‡ä»¶å¤§å°: ${filePath}`);
        const file = await fs.open(filePath, fs.OpenMode.READ_ONLY);
        try {
          const stat = await fs.stat(file.fd);
          return stat.size;
        } finally {
          await fs.close(file.fd);
        }
      } else {
        // å¯¹äºæ™®é€šè·¯å¾„ï¼Œç›´æ¥ä½¿ç”¨ fileIo.statSync
        const size = fileIo.statSync(filePath).size;
        return size;
      }
    } catch (error) {
      console.error('è·å–æ–‡ä»¶å¤§å°å¤±è´¥:', error);
      return 0;
    }
  }

  /**
   * è·å–æ–‡ä»¶å¤§å°ï¼ˆKBï¼‰- æ”¯æŒ URI å’Œæ™®é€šè·¯å¾„
   * @param filePath æ–‡ä»¶è·¯å¾„æˆ– URI
   * @returns æ–‡ä»¶å¤§å°ï¼ˆKBï¼‰
   */
  static async getFileSizeInKB(filePath: string): Promise<number> {
    const sizeInBytes = await LubanUtils.getFileSizeInBytes(filePath);
    return Math.round(sizeInBytes / 1024);
  }

  /**
   * è·å–æ–‡ä»¶å¤§å°ï¼ˆKBï¼‰- åŒæ­¥ç‰ˆæœ¬ï¼Œåªæ”¯æŒæ™®é€šæ–‡ä»¶è·¯å¾„ï¼Œä¸æ”¯æŒ URI
   * @deprecated å»ºè®®ä½¿ç”¨å¼‚æ­¥ç‰ˆæœ¬ getFileSizeInKB
   * @param filePath æ–‡ä»¶è·¯å¾„ï¼ˆä¸æ”¯æŒ URIï¼‰
   * @returns æ–‡ä»¶å¤§å°ï¼ˆKBï¼‰
   */
  static getFileSizeInKBSync(filePath: string): number {
    try {
      // æ£€æŸ¥æ˜¯å¦ä¸º URI
      if (LubanUtils.isUri(filePath)) {
        console.error('âŒ getFileSizeInKBSync ä¸æ”¯æŒ URIï¼Œè¯·ä½¿ç”¨å¼‚æ­¥ç‰ˆæœ¬ getFileSizeInKB');
        return 0;
      }

      const size = fileIo.statSync(filePath).size;
      return Math.round(size / 1024);
    } catch (error) {
      console.error('è·å–æ–‡ä»¶å¤§å°å¤±è´¥:', error);
      return 0;
    }
  }

  /**
   * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
   * @param sizeInBytes æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
   * @returns æ ¼å¼åŒ–åçš„æ–‡ä»¶å¤§å°å­—ç¬¦ä¸²
   */
  static formatFileSize(sizeInBytes: number): string {
    if (sizeInBytes < 1024) {
      return `${sizeInBytes} B`;
    } else if (sizeInBytes < 1024 * 1024) {
      return `${Math.round(sizeInBytes / 1024)} KB`;
    } else {
      return `${Math.round(sizeInBytes / (1024 * 1024) * 100) / 100} MB`;
    }
  }

  /**
   * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
   * æ³¨æ„ï¼šæ­¤æ–¹æ³•åªæ”¯æŒæ™®é€šæ–‡ä»¶è·¯å¾„ï¼Œä¸æ”¯æŒ URI
   * @param filePath æ–‡ä»¶è·¯å¾„ï¼ˆä¸æ”¯æŒ URIï¼‰
   * @returns æ–‡ä»¶æ˜¯å¦å­˜åœ¨
   */
  static fileExists(filePath: string): boolean {
    try {
      // æ£€æŸ¥æ˜¯å¦ä¸º URI
      if (LubanUtils.isUri(filePath)) {
        console.error('âŒ fileExists ä¸æ”¯æŒ URIï¼Œè¯·å…ˆä½¿ç”¨ preprocessImageFile é¢„å¤„ç†');
        return false;
      }

      return fileIo.accessSync(filePath);
    } catch (error) {
      return false;
    }
  }

  /**
   * ç¡®ä¿ç›®å½•å­˜åœ¨
   * @param dirPath ç›®å½•è·¯å¾„
   * @returns æ˜¯å¦æˆåŠŸåˆ›å»ºæˆ–å·²å­˜åœ¨
   */
  static ensureDirectoryExists(dirPath: string): boolean {
    try {
      if (!fileIo.accessSync(dirPath)) {
        fileIo.mkdirSync(dirPath, true);
      }
      return true;
    } catch (error) {
      console.error('åˆ›å»ºç›®å½•å¤±è´¥:', error);
      return false;
    }
  }

  /**
   * åˆ é™¤æ–‡ä»¶
   * @param filePath æ–‡ä»¶è·¯å¾„
   * @returns æ˜¯å¦åˆ é™¤æˆåŠŸ
   */
  static deleteFile(filePath: string): boolean {
    try {
      if (fileIo.accessSync(filePath)) {
        fileIo.unlinkSync(filePath);
        return true;
      }
      return false;
    } catch (error) {
      console.error('åˆ é™¤æ–‡ä»¶å¤±è´¥:', error);
      return false;
    }
  }

  /**
   * è·å–é»˜è®¤çš„å‹ç¼©è¾“å‡ºç›®å½•
   * @returns é»˜è®¤è¾“å‡ºç›®å½•è·¯å¾„ï¼ˆfilesDir/luban/ï¼‰
   */
  static getDefaultOutputDir(): string {
    try {
      const context = getContext();
      const outputDir = context.getApplicationContext().filesDir + '/luban';
      
      // ç¡®ä¿ç›®å½•å­˜åœ¨
      if (!fileIo.accessSync(outputDir)) {
        fileIo.mkdirSync(outputDir, true);
      }
      
      return outputDir;
    } catch (error) {
      console.error('è·å–é»˜è®¤è¾“å‡ºç›®å½•å¤±è´¥:', error);
      return '/data/storage/el2/base/files/luban';
    }
  }

  /**
   * ç”Ÿæˆå”¯ä¸€çš„æ–‡ä»¶å
   * @param originalPath åŸæ–‡ä»¶è·¯å¾„
   * @param prefix å‰ç¼€ï¼ˆå¯é€‰ï¼‰
   * @returns å”¯ä¸€çš„æ–‡ä»¶å
   */
  static generateUniqueFileName(originalPath: string, prefix: string = 'luban'): string {
    const nameWithoutExt = LubanUtils.getFileNameWithoutExtension(originalPath);
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 1000);

    return `${prefix}_${nameWithoutExt}_${timestamp}_${random}.jpg`;
  }

  /**
   * è®¡ç®—å‹ç¼©æ¯”
   * @param originalSize åŸæ–‡ä»¶å¤§å°
   * @param compressedSize å‹ç¼©åæ–‡ä»¶å¤§å°
   * @returns å‹ç¼©æ¯”ç™¾åˆ†æ¯”
   */
  static calculateCompressionRatio(originalSize: number, compressedSize: number): number {
    if (originalSize === 0) {
      return 0;
    }

    const ratio = ((originalSize - compressedSize) / originalSize) * 100;
    return Math.round(ratio * 100) / 100;
  }

  /**
   * é¢„è®¾çš„å‹ç¼©è¿‡æ»¤å™¨
   */
  static readonly FILTERS: FilterCollection = {
    /**
     * åªå‹ç¼©å›¾ç‰‡æ–‡ä»¶
     */
    IMAGES_ONLY: (path: string): boolean => {
      return LubanUtils.isImage(path);
    },

    /**
     * æ’é™¤ GIF æ–‡ä»¶
     */
    EXCLUDE_GIF: (path: string): boolean => {
      const extension = LubanUtils.getFileExtension(path);
      return LubanUtils.isImage(path) && extension !== 'gif';
    },

    /**
     * åªå‹ç¼©å¤§äºæŒ‡å®šå¤§å°çš„æ–‡ä»¶
     * @param minSizeKB æœ€å°æ–‡ä»¶å¤§å°ï¼ˆKBï¼‰
     */
    MIN_SIZE: (minSizeKB: number): CompressionPredicate => {
      return (path: string): boolean => {
        const sizeKB = LubanUtils.getFileSizeInKBSync(path);
        return sizeKB > minSizeKB;
      };
    },

    /**
     * ç»„åˆè¿‡æ»¤å™¨ï¼šåªå‹ç¼©å›¾ç‰‡ä¸”æ’é™¤ GIF ä¸”å¤§äºæŒ‡å®šå¤§å°
     * @param minSizeKB æœ€å°æ–‡ä»¶å¤§å°ï¼ˆKBï¼‰
     */
    DEFAULT: (minSizeKB: number = 100): CompressionPredicate => {
      return (path: string): boolean => {
        return LubanUtils.FILTERS.EXCLUDE_GIF(path) &&
          LubanUtils.FILTERS.MIN_SIZE(minSizeKB)(path);
      };
    }
  };

    /**
   * è·å–ä¸´æ—¶ç›®å½•ä¸‹çš„æ–‡ä»¶å¤¹è·¯å¾„æˆ–æ–‡ä»¶è·¯å¾„
   * @param dirPath æ–‡ä»¶è·¯å¾„ï¼›æ”¯æŒå®Œæ•´è·¯å¾„å’Œç›¸å¯¹è·¯å¾„ï¼ˆdownload/wps/docï¼‰ï¼›dirPathä¼ ç©ºå­—ç¬¦ä¸²è¡¨ç¤ºæ ¹ç›®å½•
   * @param fileName æ–‡ä»¶åï¼ˆtest.textï¼‰ï¼›fileNameä¼ ç©ºå­—ç¬¦ä¸²è¡¨ç¤ºæ–‡ä»¶å¤¹è·¯å¾„
   * @param blHap trueï¼šHAPçº§åˆ«æ–‡ä»¶è·¯å¾„ã€ falseï¼šAppçº§åˆ«æ–‡ä»¶è·¯å¾„
   * @returns ä¸´æ—¶ç›®å½•è·¯å¾„
   */
  static getTempDirPath(dirPath: string = "", fileName: string = "", blHap: boolean = true): string {
    try {
      const context = getContext();
      let filePath = blHap ? context.tempDir : context.getApplicationContext().tempDir; // æ ¹ç›®å½•

      if (dirPath && dirPath.trim() !== "") {
        if (LubanUtils.hasDirPath(dirPath)) { 
          // è·¯å¾„ä¸­åŒ…å«æ ¹ç›®å½•ï¼Œæ˜¯å®Œæ•´è·¯å¾„
          filePath = dirPath;
        } else { 
          // è·¯å¾„ä¸­ä¸åŒ…å«æ ¹ç›®å½•ï¼Œæ‹¼æ¥æˆå®Œæ•´è·¯å¾„
          filePath = filePath + LubanUtils.separator + dirPath;
        }
        
        if (!fileIo.accessSync(filePath)) {
          fileIo.mkdirSync(filePath, true); // å¦‚æœæ–‡ä»¶å¤¹ä¸å­˜åœ¨å°±åˆ›å»º
        }
      }
      
      if (fileName && fileName.trim() !== "") {
        filePath = filePath + LubanUtils.separator + fileName;
      }
      
      return filePath;
    } catch (error) {
      console.error('è·å–ä¸´æ—¶ç›®å½•è·¯å¾„å¤±è´¥:', error);
      throw new Error(`è·å–ä¸´æ—¶ç›®å½•å¤±è´¥: ${error}`);
    }
  }

  /**
   * è·å–ç¼“å­˜ç›®å½•ä¸‹çš„æ–‡ä»¶å¤¹è·¯å¾„æˆ–æ–‡ä»¶è·¯å¾„ï¼ˆä¿ç•™ç”¨äºç¼“å­˜æ¸…ç†ç­‰åŠŸèƒ½ï¼‰
   * @param dirPath æ–‡ä»¶è·¯å¾„ï¼›æ”¯æŒå®Œæ•´è·¯å¾„å’Œç›¸å¯¹è·¯å¾„ï¼ˆdownload/wps/docï¼‰ï¼›dirPathä¼ ç©ºå­—ç¬¦ä¸²è¡¨ç¤ºæ ¹ç›®å½•
   * @param fileName æ–‡ä»¶åï¼ˆtest.textï¼‰ï¼›fileNameä¼ ç©ºå­—ç¬¦ä¸²è¡¨ç¤ºæ–‡ä»¶å¤¹è·¯å¾„
   * @param blHap trueï¼šHAPçº§åˆ«æ–‡ä»¶è·¯å¾„ã€ falseï¼šAppçº§åˆ«æ–‡ä»¶è·¯å¾„
   * @returns ç¼“å­˜ç›®å½•è·¯å¾„
   */
  static getCacheDirPath(dirPath: string = "", fileName: string = "", blHap: boolean = true): string {
    try {
      const context = getContext();
      let filePath = blHap ? context.cacheDir : context.getApplicationContext().cacheDir; // æ ¹ç›®å½•

      if (dirPath && dirPath.trim() !== "") {
        if (LubanUtils.hasDirPath(dirPath)) { 
          // è·¯å¾„ä¸­åŒ…å«æ ¹ç›®å½•ï¼Œæ˜¯å®Œæ•´è·¯å¾„
          filePath = dirPath;
        } else { 
          // è·¯å¾„ä¸­ä¸åŒ…å«æ ¹ç›®å½•ï¼Œæ‹¼æ¥æˆå®Œæ•´è·¯å¾„
          filePath = filePath + LubanUtils.separator + dirPath;
        }
        
        if (!fileIo.accessSync(filePath)) {
          fileIo.mkdirSync(filePath, true); // å¦‚æœæ–‡ä»¶å¤¹ä¸å­˜åœ¨å°±åˆ›å»º
        }
      }
      
      if (fileName && fileName.trim() !== "") {
        filePath = filePath + LubanUtils.separator + fileName;
      }
      
      return filePath;
    } catch (error) {
      console.error('è·å–ç¼“å­˜ç›®å½•è·¯å¾„å¤±è´¥:', error);
      throw new Error(`è·å–ç¼“å­˜ç›®å½•å¤±è´¥: ${error}`);
    }
  }

  /**
   * æ£€æŸ¥è·¯å¾„æ˜¯å¦åŒ…å«ç›®å½•è·¯å¾„ï¼ˆæ˜¯å¦ä¸ºç»å¯¹è·¯å¾„ï¼‰
   * @param path è·¯å¾„å­—ç¬¦ä¸²
   * @returns æ˜¯å¦åŒ…å«ç›®å½•è·¯å¾„
   */
  private static hasDirPath(path: string): boolean {
    return path.startsWith('/') || path.includes('://');
  }

  /**
   * æ–‡ä»¶è·¯å¾„åˆ†éš”ç¬¦
   */
  private static readonly separator = '/';

  /**
   * å°†å—æƒé™é™åˆ¶çš„æ–‡ä»¶å¤åˆ¶åˆ°åº”ç”¨ä¸´æ—¶ç›®å½•
   * è§£å†³ä»ç›¸å†Œé€‰æ‹©å›¾ç‰‡æƒé™æœ‰é™çš„é—®é¢˜
   * @param srcFileUri æºæ–‡ä»¶ URIï¼ˆå¦‚ç›¸å†Œå›¾ç‰‡çš„ file:// URIï¼‰
   * @param targetDir ç›®æ ‡ç›®å½•ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä¸º lubanï¼‰
   * @returns å¤åˆ¶åçš„æ–‡ä»¶è·¯å¾„
   */
  static async copyToTemp(srcFileUri: string, targetDir: string = "luban"): Promise<string> {
    try {
      console.log('ğŸ“‹ å¼€å§‹å¤åˆ¶æ–‡ä»¶åˆ°ä¸´æ—¶ç›®å½•...');
      console.log(`ğŸ”— æºæ–‡ä»¶URI: ${srcFileUri}`);

      // ç”Ÿæˆç›®æ ‡æ–‡ä»¶è·¯å¾„
      const fileName = LubanUtils.generateTempFileName(srcFileUri);
      const tempFilePath = LubanUtils.getTempDirPath(targetDir, fileName);
      console.log(`ğŸ¯ ç›®æ ‡æ–‡ä»¶è·¯å¾„: ${tempFilePath}`);

      // æ‰“å¼€æºæ–‡ä»¶ï¼ˆåªè¯»ï¼‰- ç›´æ¥ä½¿ç”¨ URI
      console.log('ğŸ”“ æ‰“å¼€æºæ–‡ä»¶ï¼ˆä½¿ç”¨URIï¼‰...');
      const srcFile = await fs.open(srcFileUri, fs.OpenMode.READ_ONLY);

      // åˆ›å»ºç›®æ ‡æ–‡ä»¶ï¼ˆè¯»å†™+åˆ›å»ºï¼‰
      console.log('ğŸ“ åˆ›å»ºç›®æ ‡æ–‡ä»¶...');
      const mode: number = fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE;
      const destFile = await fs.open(tempFilePath, mode);

      try {
        // å¤åˆ¶æ–‡ä»¶å†…å®¹
        console.log('ğŸ“‹ æ­£åœ¨å¤åˆ¶æ–‡ä»¶å†…å®¹...');
        await fs.copyFile(srcFile.fd, destFile.fd);
        console.log('âœ… æ–‡ä»¶å¤åˆ¶æˆåŠŸ!');

        return tempFilePath;
      } finally {
        // ç¡®ä¿å…³é—­æ–‡ä»¶æè¿°ç¬¦
        try {
          await fs.close(srcFile.fd);
          await fs.close(destFile.fd);
          console.log('ğŸ”’ æ–‡ä»¶æè¿°ç¬¦å·²å…³é—­');
        } catch (closeError) {
          console.warn('âš ï¸ å…³é—­æ–‡ä»¶æè¿°ç¬¦æ—¶å‡ºç°è­¦å‘Š:', closeError);
        }
      }
    } catch (error) {
      console.error('âŒ å¤åˆ¶æ–‡ä»¶åˆ°ä¸´æ—¶ç›®å½•å¤±è´¥:', error);
      throw new Error(`å¤åˆ¶æ–‡ä»¶åˆ°ä¸´æ—¶ç›®å½•å¤±è´¥: ${error}`);
    }
  }

  /**
   * @deprecated è¯·ä½¿ç”¨ copyToTemp æ–¹æ³•
   * å°†å—æƒé™é™åˆ¶çš„æ–‡ä»¶å¤åˆ¶åˆ°åº”ç”¨ç¼“å­˜ç›®å½•
   */
  static async copyToCache(srcFileUri: string, targetDir: string = "luban_temp"): Promise<string> {
    console.warn('âš ï¸ copyToCache æ–¹æ³•å·²åºŸå¼ƒï¼Œè¯·ä½¿ç”¨ copyToTemp æ–¹æ³•');
    return await LubanUtils.copyToTemp(srcFileUri, targetDir);
  }

  /**
   * ç”Ÿæˆä¸´æ—¶æ–‡ä»¶å
   * @param originalPath åŸæ–‡ä»¶è·¯å¾„
   * @returns ç”Ÿæˆçš„ä¸´æ—¶æ–‡ä»¶å
   */
  private static generateTempFileName(originalPath: string): string {
    const extension = LubanUtils.getFileExtension(originalPath);
    const nameWithoutExt = LubanUtils.getFileNameWithoutExtension(originalPath);
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 1000);

    return `temp_${nameWithoutExt}_${timestamp}_${random}.${extension}`;
  }

  /**
   * é¢„å¤„ç†å›¾ç‰‡æ–‡ä»¶è·¯å¾„
   * å¯¹äº URIï¼Œç›´æ¥å¤åˆ¶åˆ°ä¸´æ—¶ç›®å½•ï¼›å¯¹äºæ™®é€šè·¯å¾„ï¼Œç›´æ¥è¿”å›
   * @param filePath åŸæ–‡ä»¶è·¯å¾„æˆ– URI
   * @returns å¤„ç†åçš„å¯è®¿é—®æ–‡ä»¶è·¯å¾„
   */
  static async preprocessImageFile(filePath: string): Promise<string> {
    try {
      console.log(`ğŸ”§ é¢„å¤„ç†å›¾ç‰‡æ–‡ä»¶: ${filePath}`);

      // å¦‚æœä¸æ˜¯ URIï¼Œç›´æ¥è¿”å›
      if (!LubanUtils.isUri(filePath)) {
        console.log('ğŸ“ æ™®é€šè·¯å¾„ï¼Œç›´æ¥è¿”å›');
        return filePath;
      }

      // å¯¹äº URIï¼Œç›´æ¥å¤åˆ¶åˆ°ä¸´æ—¶ç›®å½•
      console.log('ğŸ”— æ£€æµ‹åˆ° URIï¼Œå¤åˆ¶åˆ°ä¸´æ—¶ç›®å½•...');
      const tempFilePath = await LubanUtils.copyToTemp(filePath);
      console.log(`âœ… å·²å¤åˆ¶åˆ°ä¸´æ—¶ç›®å½•: ${tempFilePath}`);
      return tempFilePath;
    } catch (error) {
      console.error('âŒ é¢„å¤„ç†å›¾ç‰‡æ–‡ä»¶å¤±è´¥:', error);
      throw new Error(`é¢„å¤„ç†å›¾ç‰‡æ–‡ä»¶å¤±è´¥: ${error}`);
    }
  }

  /**
   * æ¸…ç†ä¸´æ—¶ç¼“å­˜æ–‡ä»¶ï¼ˆåŒæ—¶æ¸…ç†ä¸´æ—¶ç›®å½•å’Œç¼“å­˜ç›®å½•ï¼‰
   * @param tempDir ä¸´æ—¶ç›®å½•åï¼ˆé»˜è®¤ä¸º lubanï¼‰
   * @param cacheDir ç¼“å­˜ç›®å½•åï¼ˆé»˜è®¤ä¸º luban_tempï¼Œå…¼å®¹æ—§ç‰ˆæœ¬ï¼‰
   * @returns æ¸…ç†çš„æ–‡ä»¶æ•°é‡
   */
  static cleanTempCache(tempDir: string = "luban", cacheDir: string = "luban_temp"): number {
    try {
      let totalCleanedCount = 0;

      // æ¸…ç†ä¸´æ—¶ç›®å½•ï¼ˆæ–°ç‰ˆæœ¬ä½¿ç”¨çš„ç›®å½•ï¼‰
      const tempDirPath = LubanUtils.getTempDirPath(tempDir);
      console.log(`ğŸ§¹ æ¸…ç†ä¸´æ—¶ç›®å½•: ${tempDirPath}`);

      if (fileIo.accessSync(tempDirPath)) {
        const tempFiles = fileIo.listFileSync(tempDirPath);
        for (const fileName of tempFiles) {
          try {
            const filePath = tempDirPath + LubanUtils.separator + fileName;
            if (fileIo.statSync(filePath).isFile()) {
              fileIo.unlinkSync(filePath);
              totalCleanedCount++;
              console.log(`ğŸ—‘ï¸ åˆ é™¤ä¸´æ—¶æ–‡ä»¶: ${fileName}`);
            }
          } catch (error) {
            console.warn(`âš ï¸ æ¸…ç†ä¸´æ—¶æ–‡ä»¶å¤±è´¥: ${fileName}`, error);
          }
        }
      } else {
        console.log('ğŸ“ ä¸´æ—¶ç›®å½•ä¸å­˜åœ¨ï¼Œæ— éœ€æ¸…ç†');
      }

      // æ¸…ç†ç¼“å­˜ç›®å½•ï¼ˆå…¼å®¹æ—§ç‰ˆæœ¬ï¼‰
      const cacheDirPath = LubanUtils.getCacheDirPath(cacheDir);
      console.log(`ğŸ§¹ æ¸…ç†ç¼“å­˜ç›®å½•: ${cacheDirPath}`);

      if (fileIo.accessSync(cacheDirPath)) {
        const cacheFiles = fileIo.listFileSync(cacheDirPath);
        for (const fileName of cacheFiles) {
          try {
            const filePath = cacheDirPath + LubanUtils.separator + fileName;
            if (fileIo.statSync(filePath).isFile()) {
              fileIo.unlinkSync(filePath);
              totalCleanedCount++;
              console.log(`ğŸ—‘ï¸ åˆ é™¤ç¼“å­˜æ–‡ä»¶: ${fileName}`);
            }
          } catch (error) {
            console.warn(`âš ï¸ æ¸…ç†ç¼“å­˜æ–‡ä»¶å¤±è´¥: ${fileName}`, error);
          }
        }
      } else {
        console.log('ğŸ“ ç¼“å­˜ç›®å½•ä¸å­˜åœ¨ï¼Œæ— éœ€æ¸…ç†');
      }

      console.log(`ğŸ§¹ æ¸…ç†å®Œæˆï¼Œæ€»å…±åˆ é™¤äº† ${totalCleanedCount} ä¸ªæ–‡ä»¶`);
      return totalCleanedCount;
    } catch (error) {
      console.error('âŒ æ¸…ç†ä¸´æ—¶ç¼“å­˜å¤±è´¥:', error);
      return 0;
    }
  }

  /**
   * æµ‹è¯• URI å¤„ç†åŠŸèƒ½
   * @param uriOrPath è¦æµ‹è¯•çš„ URI æˆ–è·¯å¾„
   * @returns æµ‹è¯•ç»“æœä¿¡æ¯
   */
  static testUriHandling(uriOrPath: string): string {
    try {
      console.log(`ğŸ§ª æµ‹è¯•URIå¤„ç†: ${uriOrPath}`);

      const isUri = LubanUtils.isUri(uriOrPath);
      console.log(`ğŸ“‹ æ˜¯å¦ä¸ºURI: ${isUri}`);

      if (isUri) {
        console.log(`ğŸ”— æ£€æµ‹åˆ° URIï¼Œéœ€è¦ä½¿ç”¨ preprocessImageFile è¿›è¡Œé¢„å¤„ç†`);
        
        const isImage = LubanUtils.isImage(uriOrPath);
        console.log(`ğŸ–¼ï¸ æ˜¯å¦ä¸ºå›¾ç‰‡: ${isImage}`);
        
        return `URIæµ‹è¯•å®Œæˆ - åŸå§‹: ${uriOrPath}, ç±»å‹: URI, æ˜¯å¦ä¸ºå›¾ç‰‡: ${isImage}`;
      } else {
        // æ™®é€šè·¯å¾„çš„å¤„ç†
        const exists = LubanUtils.fileExists(uriOrPath);
        console.log(`ğŸ“‚ æ–‡ä»¶æ˜¯å¦å­˜åœ¨: ${exists}`);

        if (exists) {
          const sizeKB = LubanUtils.getFileSizeInKBSync(uriOrPath);
          console.log(`ğŸ“ æ–‡ä»¶å¤§å°: ${sizeKB} KB`);

          const isImage = LubanUtils.isImage(uriOrPath);
          console.log(`ğŸ–¼ï¸ æ˜¯å¦ä¸ºå›¾ç‰‡: ${isImage}`);
        }

        return `è·¯å¾„æµ‹è¯•å®Œæˆ - åŸå§‹: ${uriOrPath}, ç±»å‹: æ™®é€šè·¯å¾„, å­˜åœ¨: ${exists}`;
      }
    } catch (error) {
      const errorMsg = `URIå¤„ç†æµ‹è¯•å¤±è´¥: ${error}`;
      console.error(errorMsg);
      return errorMsg;
    }
  }
}